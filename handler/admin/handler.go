package admin

import (
	"alc/config"
	"alc/model/store"
	"context"
	"io"
	"mime/multipart"
	"net/http"
	"os"
	"path"
	"path/filepath"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/labstack/echo/v4"
)

type Handler struct {
	DB *pgxpool.Pool
}

func (h *Handler) InsertImage(img *multipart.FileHeader) (int, error) {
	// Source
	src, err := img.Open()
	if err != nil {
		return 0, echo.NewHTTPError(http.StatusInternalServerError, "Error opening the image")
	}
	defer src.Close()

	// Destination
	dst, err := os.CreateTemp(config.IMAGES_SAVEDIR, "*"+filepath.Ext(img.Filename))
	if err != nil {
		return 0, echo.NewHTTPError(http.StatusInternalServerError, "Error creating new image")
	}
	defer dst.Close()

	// Copy
	if _, err = io.Copy(dst, src); err != nil {
		return 0, echo.NewHTTPError(http.StatusInternalServerError, "Error saving new image")
	}

	var imgId int
	// Insert the image in the database
	if err := h.DB.QueryRow(context.Background(), `INSERT INTO images (filename)
VALUES ($1)
RETURNING id`, filepath.Base(dst.Name())).Scan(&imgId); err != nil {
		return 0, echo.NewHTTPError(http.StatusInternalServerError, "Error inserting new image into database")
	}
	return imgId, nil
}

func (h *Handler) RemoveImage(img store.Image) error {
	// Delete from filesystem, prevImgFilename must be autogenerated
	if err := os.Remove(path.Join(config.IMAGES_SAVEDIR, img.Filename)); err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, "Error deleting the image from filesystem")
	}
	// Delete from database
	if _, err := h.DB.Exec(context.Background(), `DELETE FROM images WHERE id = $1`, img.Id); err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, "Error deleting the image from database")
	}
	return nil
}

func (h *Handler) GetCategories(t store.Type) ([]store.Category, error) {
	rows, err := h.DB.Query(context.Background(), `SELECT sc.id, sc.name, sc.description, sc.slug, img.filename
FROM store_categories AS sc
LEFT JOIN images AS img
ON sc.img_id = img.id
WHERE type = $1
ORDER BY id DESC`, t)
	if err != nil {
		return []store.Category{}, echo.NewHTTPError(http.StatusInternalServerError)
	}
	defer rows.Close()

	cats, err := pgx.CollectRows(rows, func(row pgx.CollectableRow) (store.Category, error) {
		var cat store.Category
		var img *string
		err := row.Scan(&cat.Id, &cat.Name, &cat.Description, &cat.Slug, &img)
		if img != nil {
			cat.Img.Filename = *img
		} else {
			cat.Img.Filename = ""
		}
		cat.Type = t
		return cat, err
	})
	if err != nil {
		return []store.Category{}, echo.NewHTTPError(http.StatusInternalServerError)
	}
	return cats, nil
}

func (h *Handler) GetCategory(t store.Type, slug string) (store.Category, error) {
	var cat store.Category
	if err := h.DB.QueryRow(context.Background(), `SELECT id, name, description
FROM store_categories
WHERE type = $1 AND slug = $2`, t, slug).Scan(&cat.Id, &cat.Name, &cat.Description); err != nil {
		return store.Category{}, echo.NewHTTPError(http.StatusNotFound, "Category not found")
	}
	cat.Type = t
	cat.Slug = slug
	return cat, nil
}

func (h *Handler) GetItems(cat store.Category) ([]store.Item, error) {
	rows, err := h.DB.Query(context.Background(), `SELECT si.id, si.name, si.description, si.long_description, si.slug, img.filename, largeimg.filename
FROM store_items AS si
LEFT JOIN images AS img
ON si.img_id = img.id
LEFT JOIN images as largeimg
ON si.largeimg_id = largeimg.id
WHERE si.category_id = $1
ORDER BY id DESC`, cat.Id)
	if err != nil {
		return []store.Item{}, echo.NewHTTPError(http.StatusInternalServerError)
	}
	defer rows.Close()

	items, err := pgx.CollectRows(rows, func(row pgx.CollectableRow) (store.Item, error) {
		var item store.Item
		var img *string
		var largeimg *string
		err := row.Scan(&item.Id, &item.Name, &item.Description, &item.LongDescription, &item.Slug, &img, &largeimg)
		if img != nil {
			item.Img.Filename = *img
		} else {
			item.Img.Filename = ""
		}
		if largeimg != nil {
			item.LargeImg.Filename = *largeimg
		} else {
			item.LargeImg.Filename = ""
		}
		item.Category = cat
		return item, err
	})
	if err != nil {
		return []store.Item{}, echo.NewHTTPError(http.StatusInternalServerError)
	}

	return items, nil
}
